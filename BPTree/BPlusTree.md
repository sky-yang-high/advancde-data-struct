# B+树

参考[ MySQL索引B+树 ](https://blog.csdn.net/qq_40649503/article/details/115799935)。

## 二叉查找树

一个二叉树，但是满足左子树(的键值)均小于根节点，而右子树均大于根节点。

根据这个性质，可以快速从根节点匹配到目标数据。

## 平衡二叉树

二叉查找树有一个缺点，即可能左子树太矮而右子树太高，极端情况，所有数据都被放置在右子树上，如下图：

<img src="./img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjQ5NTAz,size_16,color_FFFFFF,t_70.png" alt="2" style="zoom:50%;" />

导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。

所以再优化，使用平衡二叉树(即AVL)-即左右子树的高度差不超过1.

平衡二叉树保证了树的构造是平衡的，当我们插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式这里就不介绍了。

平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。

## B 树

平衡二叉树每个结点只能存储1个键值，这导致其占用空间太大，且二叉树高度也变得很高，查找效率还是不够高。

为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树。

B 树(Balance Tree)，即平衡树，如下图所示：

![5](./img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjQ5NTAz,size_16,color_FFFFFF,t_70-1714624028080-6.png)

一个节点可以存储多个键值，且子节点也更多。把子节点个数称为阶，其查找效率进一步提高。

假如我们要查找 id=28 的用户信息，那么我们在上图 B 树中查找的流程如下：

- 先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么我们根据页 1 中的指针 p2 找到页 3。
- 将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，我们根据页 3 中的指针 p2 找到页 8。
- 将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。

## B+ 树

B+ 树即对B树的进一步优化。

![img](./img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjQ5NTAz,size_16,color_FFFFFF,t_70-1714624248729-9.png)

- B+ 树非叶子节点上不存储数据，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。

  这样做可以让一个非叶子节点存储相当多键值，从而让这棵树更矮更胖，降低查询时间。如果其阶数为1000，则高度为3的B+树即可存储10亿个键值，根节点视为常驻内存，则只需两次磁盘IO。

- B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。

   B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。

  另外，B+树的非叶子节点通过双向链表连接，而叶子节点通过单向链表连接。

- 除了这种子节点数(阶数)等于键数的形式，还有一种形式，即阶数为键数+1，如下，差别并不大：

  ![在这里插入图片描述](./img/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASm9leSBMaWFv,size_20,color_FFFFFF,t_70,g_se,x_16.png)

## B+ 树实现

参考：[B+树原理以及Go语言实现](https://segmentfault.com/a/1190000041696709#item-4)。

需要实现的功能如下：

- B+树的定义，以及B+树节点的定义
- B+树的查询操作：递归查询
- B+树的插入操作：递归插入，需要分裂处理
- B+树的删除操作：递归删除，需要合并处理

具体实现可见代码：[B+树 - go 实现](D:\Code\go\src\learn_mysql\BPTree)。

简单来说如下：

- 查询：类似于radix tree那样，不断往下走，直到叶子节点，开始遍历

- 插入：先找到合适的叶子节点插入，然后如果满了，则进行分裂，父节点的child+1，父节点也进行分裂，重复上述过程。由于查找到合适的叶子节点就是个递归操作，因此往上分裂时在递归后半部分实现即可。

  分裂策略：新建一节点，继承节点后半部分内容，并把本节点的next指向新节点

- 删除：先找到合适的叶子节点删除，如果其内容(item/child)不足一半，则优先从两边(任选一边即可)的有多余的节点抢一个过来维持原状。如果两边都不能抢，则往两边进行合并。















